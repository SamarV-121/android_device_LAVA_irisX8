From 3046e64c2911d46634564f032a8fb1c86d9bf3bc Mon Sep 17 00:00:00 2001
From: dee3000 <dee3000@bk.ru>
Date: Mon, 23 May 2016 17:32:13 +0300
Subject: [PATCH] firs

---
 healthd/BatteryMonitor.cpp   |   4 +
 include/cutils/pmem.h        | 118 +++++++++++++
 include/linux/android_pmem.h |  93 ++++++++++
 include/netutils/ifc.h       |   6 +
 init/init.c                  |   3 +
 libcutils/Android.mk         |   4 +
 libcutils/pmem-dev.cpp       | 408 +++++++++++++++++++++++++++++++++++++++++++
 libcutils/sched_policy.c     |  45 ++++-
 libnetutils/dhcp_utils.c     |  12 ++
 libnetutils/ifc_utils.c      |  62 +++++++
 libutils/Android.mk          |   4 +
 libutils/MediatekHacks.cpp   |   3 +
 mkbootimg/bootimg.h          |   2 +
 mkbootimg/mkbootimg.c        |  54 +++++-
 mkbootimg/unpackbootimg.c    |  47 +++--
 rootdir/init.rc              |  23 +--
 sdcard/sdcard.c              |  11 ++
 17 files changed, 862 insertions(+), 37 deletions(-)
 create mode 100644 include/cutils/pmem.h
 create mode 100644 include/linux/android_pmem.h
 create mode 100644 libcutils/pmem-dev.cpp
 create mode 100644 libutils/MediatekHacks.cpp

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index 66c4e8e..ba12358 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -198,7 +198,11 @@ bool BatteryMonitor::update(void) {
     props.batteryLevel = mBatteryFixedCapacity ?
         mBatteryFixedCapacity :
         getIntField(mHealthdConfig->batteryCapacityPath);
+#ifndef MTK_HARDWARE
     props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath) / 1000;
+#else
+    props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath);
+#endif
 
     props.batteryTemperature = mBatteryFixedTemperature ?
         mBatteryFixedTemperature :
diff --git a/include/cutils/pmem.h b/include/cutils/pmem.h
new file mode 100644
index 0000000..3877c27
--- /dev/null
+++ b/include/cutils/pmem.h
@@ -0,0 +1,118 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+
+
+#ifndef _CUTILS_PMEM_H
+#define _CUTILS_PMEM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Allocates a memory block which is continuous in physical memory.
+ * @param size  number of bytes to allocate
+ * @param pfd   pointer to associate file descriptor
+ * @return a void pointer to the allocated space, or NULL if there is insufficient
+ *         memory available.
+ */
+void* pmem_alloc(size_t size, int *pfd);
+
+/**
+ * Allocates a sync memory block which is continuous in physical memory.
+ * @param size  number of bytes to allocate
+ * @param pfd   pointer to associate file descriptor
+ * @return a void pointer to the allocated space, or NULL if there is insufficient
+ *         memory available.
+ */
+void* pmem_alloc_sync(size_t size, int *pfd);
+
+/**
+ * Deallocates or frees a memory block which is continuous in physical memory.
+ * @param ptr  pointer to previously allocated memory block which is allocated by pmem_alloc().
+ * @param size size of the memory block which is allocated by pmem_alloc().
+ * @param fd   associated file descriptor of the memory block which is allocated by pmem_alloc().
+ * @return 0 if success, or nagtive value if there is error
+ */
+int  pmem_free(void *ptr, size_t size, int fd);
+
+/**
+ * Convert the address of a memory block from virtual address to physical address.
+ * @param fd       associated file descriptor of the memory block which is allocated by pmem_alloc().
+ * @return a void pointer contains the physical address, or NULL if virPtr is invalid.
+ */
+void* pmem_get_phys(int fd);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _CUTILS_PMEM_H */
+ 
diff --git a/include/linux/android_pmem.h b/include/linux/android_pmem.h
new file mode 100644
index 0000000..965b511
--- /dev/null
+++ b/include/linux/android_pmem.h
@@ -0,0 +1,93 @@
+/* include/linux/android_pmem.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ANDROID_PMEM_H_
+#define _ANDROID_PMEM_H_
+
+#define PMEM_IOCTL_MAGIC 'p'
+#define PMEM_GET_PHYS		_IOW(PMEM_IOCTL_MAGIC, 1, unsigned int)
+#define PMEM_MAP		_IOW(PMEM_IOCTL_MAGIC, 2, unsigned int)
+#define PMEM_GET_SIZE		_IOW(PMEM_IOCTL_MAGIC, 3, unsigned int)
+#define PMEM_UNMAP		_IOW(PMEM_IOCTL_MAGIC, 4, unsigned int)
+/* This ioctl will allocate pmem space, backing the file, it will fail
+ * if the file already has an allocation, pass it the len as the argument
+ * to the ioctl */
+#define PMEM_ALLOCATE		_IOW(PMEM_IOCTL_MAGIC, 5, unsigned int)
+/* This will connect a one pmem file to another, pass the file that is already
+ * backed in memory as the argument to the ioctl
+ */
+#define PMEM_CONNECT		_IOW(PMEM_IOCTL_MAGIC, 6, unsigned int)
+/* Returns the total size of the pmem region it is sent to as a pmem_region
+ * struct (with offset set to 0). 
+ */
+#define PMEM_GET_TOTAL_SIZE	_IOW(PMEM_IOCTL_MAGIC, 7, unsigned int)
+#define PMEM_CACHE_FLUSH	_IOW(PMEM_IOCTL_MAGIC, 8, unsigned int)
+
+struct android_pmem_platform_data
+{
+	const char* name;
+	/* starting physical address of memory region */
+	unsigned long start;
+	/* size of memory region */
+	unsigned long size;
+	/* set to indicate the region should not be managed with an allocator */
+	unsigned no_allocator;
+	/* set to indicate maps of this region should be cached, if a mix of
+	 * cached and uncached is desired, set this and open the device with
+	 * O_SYNC to get an uncached region */
+	unsigned cached;
+	/* The MSM7k has bits to enable a write buffer in the bus controller*/
+	unsigned buffered;
+};
+
+struct pmem_region {
+	unsigned long offset;
+	unsigned long len;
+};
+
+#ifdef CONFIG_ANDROID_PMEM
+int is_pmem_file(struct file *file);
+int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
+		  unsigned long *end, struct file **filp);
+int get_pmem_user_addr(struct file *file, unsigned long *start,
+		       unsigned long *end);
+void put_pmem_file(struct file* file);
+void flush_pmem_file(struct file *file, unsigned long start, unsigned long len);
+int pmem_setup(struct android_pmem_platform_data *pdata,
+	       long (*ioctl)(struct file *, unsigned int, unsigned long),
+	       int (*release)(struct inode *, struct file *));
+int pmem_remap(struct pmem_region *region, struct file *file,
+	       unsigned operation);
+
+#else
+static inline int is_pmem_file(struct file *file) { return 0; }
+static inline int get_pmem_file(int fd, unsigned long *start,
+				unsigned long *vstart, unsigned long *end,
+				struct file **filp) { return -ENOSYS; }
+static inline int get_pmem_user_addr(struct file *file, unsigned long *start,
+				     unsigned long *end) { return -ENOSYS; }
+static inline void put_pmem_file(struct file* file) { return; }
+static inline void flush_pmem_file(struct file *file, unsigned long start,
+				   unsigned long len) { return; }
+static inline int pmem_setup(struct android_pmem_platform_data *pdata,
+	      long (*ioctl)(struct file *, unsigned int, unsigned long),
+	      int (*release)(struct inode *, struct file *)) { return -ENOSYS; }
+
+static inline int pmem_remap(struct pmem_region *region, struct file *file,
+			     unsigned operation) { return -ENOSYS; }
+#endif
+
+#endif //_ANDROID_PPP_H_
+ 
diff --git a/include/netutils/ifc.h b/include/netutils/ifc.h
index 3b27234..54f5e0a 100644
--- a/include/netutils/ifc.h
+++ b/include/netutils/ifc.h
@@ -61,6 +61,12 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
+/* MTK */
+#ifdef MTK_HARDWARE
+extern int ifc_set_txq_state(const char *ifname, int state);
+extern int ifc_ccmni_md_cfg(const char *ifname, int md_id);
+#endif /* MTK_HARDWARE */
+
 __END_DECLS
 
 #endif /* _NETUTILS_IFC_H_ */
diff --git a/init/init.c b/init/init.c
index 1cce8d8..5fe12e8 100644
--- a/init/init.c
+++ b/init/init.c
@@ -927,6 +927,9 @@ static bool selinux_is_disabled(void)
 static bool selinux_is_enforcing(void)
 {
 #ifdef ALLOW_DISABLE_SELINUX
+    /* things are getting hairier... disable during initial porting */
+    return false;
+
     char tmp[PROP_VALUE_MAX];
 
     if (property_get("ro.boot.selinux", tmp) == 0) {
diff --git a/libcutils/Android.mk b/libcutils/Android.mk
index bee2bd7..699f910 100644
--- a/libcutils/Android.mk
+++ b/libcutils/Android.mk
@@ -118,6 +118,10 @@ LOCAL_SRC_FILES := $(commonSources) \
         trace.c \
         uevent.c \
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE), true)
+LOCAL_SRC_FILES += pmem-dev.cpp
+endif
+ 
 LOCAL_SRC_FILES_arm += \
         arch-arm/memset32.S \
 
diff --git a/libcutils/pmem-dev.cpp b/libcutils/pmem-dev.cpp
new file mode 100644
index 0000000..9faf754
--- /dev/null
+++ b/libcutils/pmem-dev.cpp
@@ -0,0 +1,408 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <linux/android_pmem.h>
+#include <cutils/pmem.h>
+#include <utils/Log.h>
+
+#define LOGE    ALOGE
+
+#undef  LOG_TAG
+#define LOG_TAG "utils_pmem"
+
+#include <unwind.h>
+#include <stdlib.h>
+#include <cutils/properties.h>
+
+#define PMEM_DEVICE_NAME "/dev/pmem_multimedia"
+#define IOCTL_FAILED      -1
+#define UNMAP_FAILED      -1
+#define CLOSE_FAILED      -1
+#define INVALID_FD        -1
+//#define PAGE_SIZE       4096
+
+
+static char p_value[PROPERTY_VALUE_MAX] = "";
+static bool p_res = 0;
+
+    
+static size_t align_size(size_t size)
+{
+	return ((size + PAGE_SIZE-1) & ~(PAGE_SIZE-1));
+}
+
+// =============================================================================
+// stack trace functions
+// =============================================================================
+//
+// The statck related function is copy from bionic
+// 
+
+typedef struct
+{
+    size_t count;
+    intptr_t* addrs;
+} stack_crawl_state_t;
+
+/* depends how the system includes define this */
+#ifdef HAVE_UNWIND_CONTEXT_STRUCT
+typedef struct _Unwind_Context __unwind_context;
+#else
+typedef _Unwind_Context __unwind_context;
+#endif
+
+static _Unwind_Reason_Code trace_function(__unwind_context *context, void *arg)
+{
+    stack_crawl_state_t* state = (stack_crawl_state_t*)arg;
+    if (state->count) {
+        intptr_t ip = (intptr_t)_Unwind_GetIP(context);
+        if (ip) {
+            state->addrs[0] = ip;
+            state->addrs++;
+            state->count--;
+            return _URC_NO_REASON;
+        }
+    }
+    /*
+     * If we run out of space to record the address or 0 has been seen, stop
+     * unwinding the stack.
+     */
+    return _URC_END_OF_STACK;
+}
+
+static inline
+int get_backtrace(intptr_t* addrs, size_t max_entries)
+{
+    stack_crawl_state_t state;
+    state.count = max_entries;
+    state.addrs = (intptr_t*)addrs;
+    _Unwind_Backtrace(trace_function, (void*)&state);
+    return max_entries - state.count;
+}
+
+static void dump_stack_trace()
+{
+    intptr_t addrs[20];
+    int c = get_backtrace(addrs, 20);
+    char buf[21];
+    char tmp[21*20];
+    int i;
+
+    tmp[0] = 0; // Need to initialize tmp[0] for the first strcat
+    for (i=0 ; i<c; i++) {
+        snprintf(buf, sizeof buf, "[PMEM]%2d: %08x\n", i, addrs[i]);
+        strlcat(tmp, buf, sizeof tmp);
+    }
+    //__libc_android_log_print(ANDROID_LOG_ERROR, "libc", "call stack:\n%s", tmp);
+    LOGE("[PMEM] call stack:\n%s", tmp);
+}
+
+void* pmem_alloc(size_t size, int *pfd)
+{
+    int         fd;
+    size_t      aligned_size;
+    void*       base;
+    pmem_region region = { 0, 0 };
+    int         err;
+
+    if (NULL == pfd)
+    {
+        return NULL;
+    }
+
+    *pfd = -1;
+    
+    fd = open(PMEM_DEVICE_NAME, (O_RDWR | O_SYNC));
+    if (INVALID_FD == fd)
+    {
+        LOGE("[PMEM] open %s failed!", PMEM_DEVICE_NAME);
+        goto open_failed;
+    }
+
+    aligned_size = align_size(size);
+    base = mmap(0, aligned_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (MAP_FAILED == base) 
+    {
+        LOGE("[PMEM] mmap size %d failed!", aligned_size);
+        goto mmap_failed;
+    }
+    
+    region.len = aligned_size;
+    err = ioctl(fd, PMEM_MAP, &region);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("[PMEM] PMEM_MAP size %d failed!", aligned_size);
+        goto pmem_map_failed;
+    }
+
+    property_get("pm.dumpstack", p_value, "0"); //if not set, disable by default 
+    p_res = atoi(p_value);
+    if (p_res) 
+    {
+        LOGE("[PMEM] pmem_alloc: base: 0x%08x, size: %d\n", (int)base, aligned_size);
+        dump_stack_trace();
+    }
+
+    *pfd = fd;
+    
+    return base;
+
+
+insert_failed:
+    ioctl(fd, PMEM_UNMAP, &region);
+pmem_map_failed:
+    munmap(base, aligned_size);
+mmap_failed:
+    close(fd);
+open_failed:
+    return NULL;    
+}
+
+
+void* pmem_alloc_sync(size_t size, int *pfd)
+{
+    int         fd;
+    size_t      aligned_size;
+    void*       base;
+    pmem_region region = { 0, 0 };
+    int         err;
+
+	if (NULL == pfd)
+	{
+		return NULL;
+	}
+
+	*pfd = -1;
+    
+    fd = open(PMEM_DEVICE_NAME, O_RDWR|O_SYNC);
+    if (INVALID_FD == fd)
+    {
+        LOGE("[PMEM] open %s failed!", PMEM_DEVICE_NAME);
+        goto open_failed;
+    }
+
+    aligned_size = align_size(size);
+    base = mmap(0, aligned_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (MAP_FAILED == base) 
+    {
+        LOGE("[PMEM] mmap size %d failed!", aligned_size);
+        goto mmap_failed;
+    }
+    
+    region.len = aligned_size;
+    err = ioctl(fd, PMEM_MAP, &region);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("[PMEM] PMEM_MAP size %d failed!", aligned_size);
+        goto pmem_map_failed;
+    }
+
+    property_get("pm.dumpstack", p_value, "0"); //if not set, disable by default 
+    p_res = atoi(p_value);
+    if (p_res) 
+    {
+        LOGE("[PMEM] pmem_alloc_sync: base: 0x%08x, size: %d\n", (int)base, aligned_size);
+        dump_stack_trace();
+    }
+
+    *pfd = fd;
+    return base;
+
+
+insert_failed:
+    ioctl(fd, PMEM_UNMAP, &region);
+pmem_map_failed:
+    munmap(base, aligned_size);
+mmap_failed:
+    close(fd);
+open_failed:
+    return NULL;    
+}
+
+
+int  pmem_free(void *ptr, size_t size, int fd)
+{
+    int err, ret = 0;
+    size_t aligned_size = align_size(size);    
+
+    pmem_region region = { 0, aligned_size };
+    err = ioctl(fd, PMEM_UNMAP, &region);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("PMEM_UNMAP size %d failed!", size);
+        ret = err;
+    }
+    
+    err = munmap(ptr, aligned_size);
+    if (UNMAP_FAILED == err)
+    {
+        LOGE("mumap size %d failed!", size);
+        ret = err;
+    }    
+
+    err = close(fd);
+    if (CLOSE_FAILED == err)
+    {
+        LOGE("Close file %d failed!", fd);
+        ret = err;
+    }
+
+
+    property_get("pm.dumpstack", p_value, "0"); //if not set, disable by default 
+    p_res = atoi(p_value);
+    if (p_res) 
+    {
+        LOGE("[PMEM] pmem_free: base: 0x%08x, size: %d\n", (int)ptr, aligned_size);
+        dump_stack_trace();
+    }
+
+    
+    return ret;
+}
+
+
+void* pmem_get_phys(int fd)
+{
+    pmem_region pmem_reg;
+    int err = ioctl(fd, PMEM_GET_PHYS, &pmem_reg);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("PMEM_GET_PHYS failed: 0x%X !", fd);
+        return NULL;
+    }
+
+    return (void*)(pmem_reg.offset);
+}
+
+void pmem_cache_flush(int fd, unsigned int offset, unsigned int length) {
+    pmem_region region = { 0, 0 };
+    int         err = -1; 
+
+    if (fd < 0 || offset == 0 || length == 0) {
+        LOGE("pmem_cache_flush: invalide argument\n");
+        return;
+    }   
+
+    region.offset = offset;
+    region.len = length;
+    err = ioctl(fd, PMEM_CACHE_FLUSH, &region);
+    if (IOCTL_FAILED == err)
+    {   
+        LOGE("PMEM_CACHE_FLUSH offset 0x%08x, size %d failed!\n", offset, length);
+    }
+}
+
+
+
+/* No clean & INV function in ICS */
+#if 0
+void pmem_cache_clean(int fd, unsigned int offset, unsigned int length) {
+    pmem_region region = { 0, 0 };
+    int         err = -1; 
+
+    if (fd < 0 || offset == 0 || length == 0) {
+        LOGE("pmem_cache_clean: invalide argument\n");
+        return;
+    }   
+
+    region.offset = offset;
+    region.len = length;
+    err = ioctl(fd, PMEM_CACHE_CLEAN, &region);
+    if (IOCTL_FAILED == err)
+    {   
+        LOGE("PMEM_CACHE_CLEAN offset 0x%08x, size %d failed!\n", offset, length);
+    }
+}
+
+
+void pmem_cache_inv(int fd, unsigned int offset, unsigned int length) {
+    pmem_region region = { 0, 0 };
+    int         err = -1; 
+
+    if (fd < 0 || offset == 0 || length == 0) {
+        LOGE("pmem_cache_inv: invalide argument\n");
+        return;
+    }   
+
+    region.offset = offset;
+    region.len = length;
+    err = ioctl(fd, PMEM_CACHE_INV, &region);
+    if (IOCTL_FAILED == err)
+    {   
+        LOGE("PMEM_CACHE_INV offset 0x%08x, size %d failed!\n", offset, length);
+    }
+}
+#endif
+ 
diff --git a/libcutils/sched_policy.c b/libcutils/sched_policy.c
index 493511e..9d7597d 100644
--- a/libcutils/sched_policy.c
+++ b/libcutils/sched_policy.c
@@ -55,6 +55,8 @@ static pthread_once_t the_once = PTHREAD_ONCE_INIT;
 
 static int __sys_supports_schedgroups = -1;
 
+static int is_mtk_schedgroups = 0;
+
 // File descriptors open to /dev/cpuctl/../tasks, setup by initialize, or -1 on error.
 static int bg_cgroup_fd = -1;
 static int fg_cgroup_fd = -1;
@@ -110,7 +112,7 @@ static int add_tid_to_cgroup(int tid, SchedPolicy policy)
 
 static void __initialize(void) {
     char* filename;
-    if (!access("/dev/cpuctl/tasks", F_OK)) {
+    if (access("/dev/cpuctl/apps", F_OK) == -ENOENT && !access("/dev/cpuctl/tasks", F_OK)) {
         __sys_supports_schedgroups = 1;
 
         filename = "/dev/cpuctl/tasks";
@@ -124,6 +126,22 @@ static void __initialize(void) {
         if (bg_cgroup_fd < 0) {
             SLOGE("open of %s failed: %s\n", filename, strerror(errno));
         }
+    } else if (!access("/dev/cpuctl/apps/tasks", F_OK)) {
+        /* be compatible with MTK cgroup hierarchy */
+        __sys_supports_schedgroups = 1;
+        is_mtk_schedgroups = 1;
+
+        filename = "/dev/cpuctl/apps/tasks";
+        fg_cgroup_fd = open(filename, O_WRONLY | O_CLOEXEC);
+        if (fg_cgroup_fd < 0) {
+            SLOGE("open of %s failed: %s\n", filename, strerror(errno));
+        }
+
+        filename = "/dev/cpuctl/apps/bg_non_interactive/tasks";
+        bg_cgroup_fd = open(filename, O_WRONLY | O_CLOEXEC);
+        if (bg_cgroup_fd < 0) {
+            SLOGE("open of %s failed: %s\n", filename, strerror(errno));
+        }
     } else {
         __sys_supports_schedgroups = 0;
     }
@@ -214,13 +232,26 @@ int get_sched_policy(int tid, SchedPolicy *policy)
         char grpBuf[32];
         if (getSchedulerGroup(tid, grpBuf, sizeof(grpBuf)) < 0)
             return -1;
-        if (grpBuf[0] == '\0') {
-            *policy = SP_FOREGROUND;
-        } else if (!strcmp(grpBuf, "bg_non_interactive")) {
-            *policy = SP_BACKGROUND;
+        if (is_mtk_schedgroups) {
+            /* MTK cgroup hierarchy */
+            if (!strcmp(grpBuf, "apps")) {
+                *policy = SP_FOREGROUND;
+            } else if (!strcmp(grpBuf, "apps/bg_non_interactive")) {
+                *policy = SP_BACKGROUND;
+            } else {
+                errno = ERANGE;
+                return -1;
+            }
         } else {
-            errno = ERANGE;
-            return -1;
+            /* AOSP cgroup hierarchy */
+            if (grpBuf[0] == '\0') {
+                *policy = SP_FOREGROUND;
+            } else if (!strcmp(grpBuf, "bg_non_interactive")) {
+                *policy = SP_BACKGROUND;
+            } else {
+                errno = ERANGE;
+                return -1;
+            }
         }
     } else {
         int rc = sched_getscheduler(tid);
diff --git a/libnetutils/dhcp_utils.c b/libnetutils/dhcp_utils.c
index e1df874..db90652 100644
--- a/libnetutils/dhcp_utils.c
+++ b/libnetutils/dhcp_utils.c
@@ -216,6 +216,18 @@ int dhcp_do_request(const char *interface,
     /* Erase any previous setting of the dhcp result property */
     property_set(result_prop_name, "");
 
+    /* HACK: Sometimes the lease file appears to be corrupted, which can cause
+     * unknown errors while obtaining an address. We just remove the corresponding
+     * lease file prior to starting the daemon...
+     */
+    {
+        char lease_file_path[PROPERTY_VALUE_MAX];
+        snprintf(lease_file_path, sizeof(lease_file_path),
+                "/data/misc/dhcp/dhcpcd-%s.lease",
+                p2p_interface);
+        unlink(lease_file_path);
+    }
+
     /* Start the daemon and wait until it's ready */
     if (property_get(HOSTNAME_PROP_NAME, prop_value, NULL) && (prop_value[0] != '\0'))
         snprintf(daemon_cmd, sizeof(daemon_cmd), "%s_%s:-f %s -h %s %s", DAEMON_NAME,
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index cb3722d..5a6591e 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -711,3 +711,65 @@ ifc_configure(const char *ifname,
 
     return 0;
 }
+
+
+/* MTK */
+#ifdef MTK_HARDWARE
+
+#define SIOCSTXQSTATE (SIOCDEVPRIVATE + 0)  //start/stop ccmni tx queue
+#define SIOCSCCMNICFG (SIOCDEVPRIVATE + 1)  //configure ccmni/md remapping
+
+int ifc_set_txq_state(const char *ifname, int state)
+{
+    struct ifreq ifr;
+    int ret, ctl_sock;
+
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
+    ifr.ifr_ifru.ifru_ivalue = state;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        ALOGE("create ctl socket failed\n");
+        return -1;
+    }
+    ret = ioctl(ctl_sock, SIOCSTXQSTATE, &ifr);
+    if(ret < 0)
+        ALOGE("ifc_set_txq_state failed, err:%d(%s)\n", errno, strerror(errno));
+    else
+        ALOGI("ifc_set_txq_state as %d, ret: %d\n", state, ret);
+
+    close(ctl_sock);
+
+    return ret;
+}
+
+int ifc_ccmni_md_cfg(const char *ifname, int md_id)
+{
+    struct ifreq ifr;
+    int ret = 0;
+    int ctl_sock = 0;
+
+    ifc_init_ifr(ifname, &ifr);
+    ifr.ifr_ifru.ifru_ivalue = md_id;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        printerr("ifc_ccmni_md_cfg: create ctl socket failed\n");
+        return -1;
+    }
+
+    if(ioctl(ctl_sock, SIOCSCCMNICFG, &ifr) < 0) {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) error:%d(%s)", \
+            ifname, md_id, errno, strerror(errno));
+        ret = -1;
+    } else {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) OK", ifname, md_id);
+    }
+
+    close(ctl_sock);
+    return ret;
+}
+
+#endif /* MTK_HARDWARE */
diff --git a/libutils/Android.mk b/libutils/Android.mk
index 035846b..806881a 100644
--- a/libutils/Android.mk
+++ b/libutils/Android.mk
@@ -91,6 +91,10 @@ LOCAL_CFLAGS += -DALIGN_DOUBLE
 endif
 LOCAL_CFLAGS += -Werror
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE), true)
+LOCAL_SRC_FILES += MediatekHacks.cpp
+endif
+
 LOCAL_C_INCLUDES += \
 		bionic/libc \
 		external/zlib
diff --git a/libutils/MediatekHacks.cpp b/libutils/MediatekHacks.cpp
new file mode 100644
index 0000000..e775ee6
--- /dev/null
+++ b/libutils/MediatekHacks.cpp
@@ -0,0 +1,3 @@
+extern "C" {
+ void _ZN7android11IDumpTunnel11asInterfaceERKNS_2spINS_7IBinderEEE(){}
+} 
diff --git a/mkbootimg/bootimg.h b/mkbootimg/bootimg.h
index 308c537..bf3b1dc 100644
--- a/mkbootimg/bootimg.h
+++ b/mkbootimg/bootimg.h
@@ -26,6 +26,8 @@ typedef struct boot_img_hdr boot_img_hdr;
 #define BOOT_ARGS_SIZE 512
 #define BOOT_EXTRA_ARGS_SIZE 1024
 
+#define MTK_HEADER_SIZE 512
+
 struct boot_img_hdr
 {
     unsigned char magic[BOOT_MAGIC_SIZE];
diff --git a/mkbootimg/mkbootimg.c b/mkbootimg/mkbootimg.c
index 38b4b37..80676a4 100644
--- a/mkbootimg/mkbootimg.c
+++ b/mkbootimg/mkbootimg.c
@@ -25,10 +25,12 @@
 #include "mincrypt/sha.h"
 #include "bootimg.h"
 
-static void *load_file(const char *fn, unsigned *_sz)
+static void *load_file(const char *fn, unsigned *_sz, int is_mtk, const char *mtk_fn)
 {
     char *data;
+    char *buf_start;
     int sz;
+    int buf_sz;
     int fd;
 
     data = 0;
@@ -40,13 +42,36 @@ static void *load_file(const char *fn, unsigned *_sz)
 
     if(lseek(fd, 0, SEEK_SET) != 0) goto oops;
 
-    data = (char*) malloc(sz);
+    buf_sz = sz + (is_mtk ? MTK_HEADER_SIZE : 0);
+    data = buf_start = (char*) malloc(buf_sz);
     if(data == 0) goto oops;
 
-    if(read(fd, data, sz) != sz) goto oops;
+    if (is_mtk) {
+        /* MTK magic */
+        data[0] = 0x88;
+        data[1] = 0x16;
+        data[2] = 0x88;
+        data[3] = 0x58;
+
+        /* file length in little endian */
+        data[4] = sz & 0xFF;
+        data[5] = (sz >> 8) & 0xFF;
+        data[6] = (sz >> 16) & 0xFF;
+        data[7] = (sz >> 24) & 0xFF;
+
+        /* MTK "file name" */
+        strncpy(data + 8, mtk_fn, 32);
+
+        /* MTK header padding */
+        memset(data + 40, 0xff, MTK_HEADER_SIZE - 40);
+
+        buf_start += MTK_HEADER_SIZE;
+    }
+
+    if(read(fd, buf_start, sz) != sz) goto oops;
     close(fd);
 
-    if(_sz) *_sz = sz;
+    if(_sz) *_sz = buf_sz;
     return data;
 
 oops:
@@ -68,6 +93,7 @@ int usage(void)
             "       [ --dt <filename> ]\n"
             "       [ --ramdisk_offset <address> ]\n"
             "       [ --tags_offset <address> ]\n"
+            "       [ --mtk <boot|recovery> ]\n"
             "       -o|--output <filename>\n"
             );
     return 1;
@@ -99,6 +125,8 @@ int main(int argc, char **argv)
 {
     boot_img_hdr hdr;
 
+    int is_mtk = 0;
+    int is_mtk_boot = 0;
     char *kernel_fn = 0;
     void *kernel_data = 0;
     char *ramdisk_fn = 0;
@@ -167,6 +195,16 @@ int main(int argc, char **argv)
             }
         } else if(!strcmp(arg, "--dt")) {
             dt_fn = val;
+        } else if (!strcmp(arg, "--mtk")) {
+            if (!strcmp(val, "boot")) {
+                is_mtk = 1;
+                is_mtk_boot = 1;
+            } else if (!strcmp(val, "recovery")) {
+                is_mtk = 1;
+                is_mtk_boot = 0;
+            } else {
+                return usage();
+            }
         } else {
             return usage();
         }
@@ -216,7 +254,7 @@ int main(int argc, char **argv)
         strncpy((char *)hdr.extra_cmdline, cmdline, BOOT_EXTRA_ARGS_SIZE);
     }
 
-    kernel_data = load_file(kernel_fn, &hdr.kernel_size);
+    kernel_data = load_file(kernel_fn, &hdr.kernel_size, is_mtk, "KERNEL");
     if(kernel_data == 0) {
         fprintf(stderr,"error: could not load kernel '%s'\n", kernel_fn);
         return 1;
@@ -226,7 +264,7 @@ int main(int argc, char **argv)
         ramdisk_data = 0;
         hdr.ramdisk_size = 0;
     } else {
-        ramdisk_data = load_file(ramdisk_fn, &hdr.ramdisk_size);
+        ramdisk_data = load_file(ramdisk_fn, &hdr.ramdisk_size, is_mtk, is_mtk_boot ? "ROOTFS" : "RECOVERY");
         if(ramdisk_data == 0) {
             fprintf(stderr,"error: could not load ramdisk '%s'\n", ramdisk_fn);
             return 1;
@@ -234,7 +272,7 @@ int main(int argc, char **argv)
     }
 
     if(second_fn) {
-        second_data = load_file(second_fn, &hdr.second_size);
+        second_data = load_file(second_fn, &hdr.second_size, is_mtk, "");
         if(second_data == 0) {
             fprintf(stderr,"error: could not load secondstage '%s'\n", second_fn);
             return 1;
@@ -242,7 +280,7 @@ int main(int argc, char **argv)
     }
 
     if(dt_fn) {
-        dt_data = load_file(dt_fn, &hdr.dt_size);
+        dt_data = load_file(dt_fn, &hdr.dt_size, is_mtk, "");
         if (dt_data == 0) {
             fprintf(stderr,"error: could not load device tree image '%s'\n", dt_fn);
             return 1;
diff --git a/mkbootimg/unpackbootimg.c b/mkbootimg/unpackbootimg.c
index 3d2fda7..d844cfd 100644
--- a/mkbootimg/unpackbootimg.c
+++ b/mkbootimg/unpackbootimg.c
@@ -38,11 +38,21 @@ void write_string_to_file(char* file, char* string)
     fclose(f);
 }
 
+void maybe_skip_mtk_header(FILE* f, int is_mtk)
+{
+    if (!is_mtk) {
+        return;
+    }
+
+    fseek(f, MTK_HEADER_SIZE, SEEK_CUR);
+}
+
 int usage() {
     printf("usage: unpackbootimg\n");
     printf("\t-i|--input boot.img\n");
     printf("\t[ -o|--output output_directory]\n");
     printf("\t[ -p|--pagesize <size-in-hexadecimal> ]\n");
+    printf("\t[ --mtk 1 ]\n");
     return 0;
 }
 
@@ -52,6 +62,7 @@ int main(int argc, char** argv)
     char* directory = "./";
     char* filename = NULL;
     int pagesize = 0;
+    int is_mtk = 0;
 
     argc--;
     argv++;
@@ -66,6 +77,12 @@ int main(int argc, char** argv)
             directory = val;
         } else if(!strcmp(arg, "--pagesize") || !strcmp(arg, "-p")) {
             pagesize = strtoul(val, 0, 16);
+        } else if (!strcmp(arg, "--mtk")) {
+            if (!strcmp(val, "1")) {
+                is_mtk = 1;
+            }
+
+            return usage();
         } else {
             return usage();
         }
@@ -153,23 +170,27 @@ int main(int argc, char** argv)
     //printf("total read: %d\n", total_read);
     total_read += read_padding(f, sizeof(header), pagesize);
 
+    int mtk_size_adjust = is_mtk ? -MTK_HEADER_SIZE : 0;
+
     sprintf(tmp, "%s/%s", directory, basename(filename));
     strcat(tmp, "-zImage");
     FILE *k = fopen(tmp, "wb");
-    byte* kernel = (byte*)malloc(header.kernel_size);
+    byte* kernel = (byte*)malloc(header.kernel_size + mtk_size_adjust);
     //printf("Reading kernel...\n");
-    fread(kernel, header.kernel_size, 1, f);
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(kernel, header.kernel_size + mtk_size_adjust, 1, f);
     total_read += header.kernel_size;
-    fwrite(kernel, header.kernel_size, 1, k);
+    fwrite(kernel, header.kernel_size + mtk_size_adjust, 1, k);
     fclose(k);
 
     //printf("total read: %d\n", header.kernel_size);
     total_read += read_padding(f, header.kernel_size, pagesize);
 
 
-    byte* ramdisk = (byte*)malloc(header.ramdisk_size);
+    byte* ramdisk = (byte*)malloc(header.ramdisk_size + mtk_size_adjust);
     //printf("Reading ramdisk...\n");
-    fread(ramdisk, header.ramdisk_size, 1, f);
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(ramdisk, header.ramdisk_size + mtk_size_adjust, 1, f);
     total_read += header.ramdisk_size;
     sprintf(tmp, "%s/%s", directory, basename(filename));
     if(ramdisk[0] == 0x02 && ramdisk[1]== 0x21)
@@ -177,7 +198,7 @@ int main(int argc, char** argv)
     else
         strcat(tmp, "-ramdisk.gz");
     FILE *r = fopen(tmp, "wb");
-    fwrite(ramdisk, header.ramdisk_size, 1, r);
+    fwrite(ramdisk, header.ramdisk_size + mtk_size_adjust, 1, r);
     fclose(r);
 
     total_read += read_padding(f, header.ramdisk_size, pagesize);
@@ -185,11 +206,12 @@ int main(int argc, char** argv)
     sprintf(tmp, "%s/%s", directory, basename(filename));
     strcat(tmp, "-second");
     FILE *s = fopen(tmp, "wb");
-    byte* second = (byte*)malloc(header.second_size);
+    byte* second = (byte*)malloc(header.second_size + mtk_size_adjust);
     //printf("Reading second...\n");
-    fread(second, header.second_size, 1, f);
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(second, header.second_size + mtk_size_adjust, 1, f);
     total_read += header.second_size;
-    fwrite(second, header.second_size, 1, r);
+    fwrite(second, header.second_size + mtk_size_adjust, 1, r);
     fclose(s);
 
     total_read += read_padding(f, header.second_size, pagesize);
@@ -197,11 +219,12 @@ int main(int argc, char** argv)
     sprintf(tmp, "%s/%s", directory, basename(filename));
     strcat(tmp, "-dt");
     FILE *d = fopen(tmp, "wb");
-    byte* dt = (byte*)malloc(header.dt_size);
+    byte* dt = (byte*)malloc(header.dt_size + mtk_size_adjust);
     //printf("Reading dt...\n");
-    fread(dt, header.dt_size, 1, f);
+    maybe_skip_mtk_header(f, is_mtk);
+    fread(dt, header.dt_size + mtk_size_adjust, 1, f);
     total_read += header.dt_size;
-    fwrite(dt, header.dt_size, 1, r);
+    fwrite(dt, header.dt_size + mtk_size_adjust, 1, r);
     fclose(d);
     
     fclose(f);
diff --git a/rootdir/init.rc b/rootdir/init.rc
index 001ab13..a8bd4b0 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -554,12 +554,12 @@ service debuggerd /system/bin/debuggerd
 service debuggerd64 /system/bin/debuggerd64
     class main
 
-service ril-daemon /system/bin/rild
-    class main
-    socket rild stream 660 root radio
-    socket rild-debug stream 660 radio system
-    user root
-    group radio cache inet misc audio sdcard_rw qcom_diag log
+#service ril-daemon /system/bin/rild
+#    class main
+#    socket rild stream 660 root radio
+#    socket rild-debug stream 660 radio system
+#    user root
+#    group radio cache inet misc audio sdcard_rw qcom_diag log
 
 service surfaceflinger /system/bin/surfaceflinger
     class core
@@ -570,12 +570,14 @@ service surfaceflinger /system/bin/surfaceflinger
 service drm /system/bin/drmserver
     class main
     user drm
-    group drm system inet drmrpc
+	# MTK
+    group drm system inet drmrpc sdcard_r
 
 service media /system/bin/mediaserver
     class main
-    user media
-    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm qcom_diag
+	# MTK
+    user root
+    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm media sdcard_r system net_bt_stack qcom_diag
     ioprio rt 4
 
 # One shot invocation to deal with encrypted volume.
@@ -595,7 +597,8 @@ service encrypt /system/bin/vdc --wait cryptfs enablecrypto inplace default
 service bootanim /system/bin/bootanimation
     class core
     user graphics
-    group graphics audio
+	# MTK
+    group graphics media audio
     disabled
     oneshot
 
diff --git a/sdcard/sdcard.c b/sdcard/sdcard.c
index a29462c..6522f91 100644
--- a/sdcard/sdcard.c
+++ b/sdcard/sdcard.c
@@ -1951,6 +1951,17 @@ int sdcard_main(int argc, char **argv)
             uid = strtoul(arg, NULL, 10);
         } else if (!gid) {
             gid = strtoul(arg, NULL, 10);
+        } else if (!strcmp(arg, ".@meizu_protbox@")) {
+            /* Flyme hack: There are two extra arguments passed when using
+             * Flyme boot.img, which is irrelevant on CM. We should check for
+             * them and stop processing when found.
+             *
+             * As the actual parameters passed is appended to the end of the
+             * command line, we can simplify a bit by just breaking on
+             * encountering the signature string.
+             */
+            TRACE("ignoring extra arguments on Flyme");
+            break;
         } else {
             ERROR("too many arguments\n");
             return usage();
-- 
1.9.1

